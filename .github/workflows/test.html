<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Physics Scene</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0c0c14;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #f0f0f0;
        }
        canvas {
            display: block;
            background-color: #1a1a2e;
        }
        #ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(40, 40, 70, 0.85);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(128, 128, 160, 0.5);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-weight: 500;
        }
        .control-group input, .control-group select, .control-group button {
            width: 100%;
            box-sizing: border-box;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #eee;
            font-size: 0.9em;
        }
        .control-group button {
            background: #4a4e69;
            cursor: pointer;
            margin-top: 5px;
            font-weight: bold;
        }
        .control-group button:hover {
            background: #6a6e99;
        }
        .range-label {
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <canvas id="physicsCanvas"></canvas>

    <div id="ui-panel">
        <div class="control-group">
            <label for="polygonSides">Polygon Sides: <span id="polygonSidesValue">6</span></label>
            <input type="range" id="polygonSides" min="3" max="16" value="6">
        </div>
        <div class="control-group">
            <label for="ballsCount">Balls: <span id="ballsCountValue">12</span></label>
            <input type="range" id="ballsCount" min="1" max="100" value="12">
        </div>
        <div class="control-group">
            <label for="spinSpeed">Spin Speed: <span id="spinSpeedValue">0.8</span> rad/s</label>
            <input type="range" id="spinSpeed" min="-2" max="2" step="0.1" value="0.8">
        </div>
        <div class="control-group">
            <label for="timeScale">Time Scale: <span id="timeScaleValue">1.0</span>x</label>
            <input type="range" id="timeScale" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label for="trail">Trails:</label>
            <input type="checkbox" id="trail" checked>
        </div>
        <div class="control-group">
            <button id="randomizeBtn">Randomize</button>
            <button id="pauseBtn">Pause</button>
        </div>
    </div>

    <script>
    // --- CONFIGURATION ---
    const config = {
        polygonSides: 6,
        polygonSize: 180, // radius in pixels
        spinSpeed: 0.8, // rad/s
        ballsCount: 12,
        gravityMode: "varying", // "varying", "constant"
        gravityMagnitudeRange: [200, 800], // [min, max]
        gravityDirectionChangeSpeed: 0.2, // rad/s
        polygonBounceRestitution: 0.6,
        ballRestitution: 0.8,
        wallRestitution: 0.9,
        ballRadiusRange: [8, 15],
        ballMassFromRadius: true,
        polygonLinearDamping: 0.1,
        polygonAngularDamping: 0.1,
        colorMode: "dynamic",
        trail: true,
        trailFadeAmount: 0.15,
        paused: false,
        timeScale: 1.0,
        
        // Physics engine tuning
        substeps: 4, // Iterations per frame for stability
        slop: 0.05, // Penetration allowance
        baumgarte: 0.2, // Positional correction factor
        friction: 0.1, // Simple ball-wall friction
    };

    // --- GLOBAL STATE ---
    const canvas = document.getElementById('physicsCanvas');
    const ctx = canvas.getContext('2d');
    let width, height, dpr;

    let polygon;
    let balls = [];
    let gravity = { x: 0, y: 400 };
    let gravityAngle = Math.PI / 2;

    let lastTime = 0;
    let animationFrameId;

    // --- UTILITY FUNCTIONS ---

    // Vector operations
    const Vec = {
        add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
        sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
        scale: (v, s) => ({ x: v.x * s, y: v.y * s }),
        dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
        cross: (v1, v2) => v1.x * v2.y - v1.y * v2.x, // 2D cross product (returns scalar)
        lenSq: (v) => v.x * v.x + v.y * v.y,
        len: (v) => Math.sqrt(v.x * v.x + v.y * v.y),
        normalize: (v) => {
            const l = Vec.len(v);
            return l > 0 ? { x: v.x / l, y: v.y / l } : { x: 0, y: 0 };
        },
        rotate: (v, angle) => ({
            x: v.x * Math.cos(angle) - v.y * Math.sin(angle),
            y: v.x * Math.sin(angle) + v.y * Math.cos(angle)
        }),
    };

    // --- PHYSICS CLASSES ---

    /**
     * Represents the spinning polygonal container.
     */
    class Polygon {
        constructor() {
            this.pos = { x: width / 2, y: height / 2 };
            this.vel = { x: (Math.random() - 0.5) * 200, y: (Math.random() - 0.5) * 200 };
            this.angle = Math.random() * 2 * Math.PI;
            this.angularVel = config.spinSpeed;
            this.restitution = config.polygonBounceRestitution;
            this.linearDamping = config.polygonLinearDamping;
            this.angularDamping = config.angularDamping;

            this.mass = 100;
            this.invMass = 1 / this.mass;
            // Moment of inertia for a regular polygon (approximation)
            this.inertia = this.mass * config.polygonSize * config.polygonSize * (1/2 + 1/12 * Math.pow(Math.tan(Math.PI/config.polygonSides), 2));
            this.invInertia = 1 / this.inertia;

            this.localVertices = [];
            this.worldVertices = [];
            this.worldNormals = [];
            this.generateVertices();
        }

        generateVertices() {
            this.localVertices = [];
            for (let i = 0; i < config.polygonSides; i++) {
                const angle = (i / config.polygonSides) * 2 * Math.PI;
                this.localVertices.push({
                    x: config.polygonSize * Math.cos(angle),
                    y: config.polygonSize * Math.sin(angle)
                });
            }
            this.updateWorldVertices();
        }

        updateWorldVertices() {
            this.worldVertices = this.localVertices.map(v => Vec.add(this.pos, Vec.rotate(v, this.angle)));
            this.worldNormals = [];
             for (let i = 0; i < this.worldVertices.length; i++) {
                const p1 = this.worldVertices[i];
                const p2 = this.worldVertices[(i + 1) % this.worldVertices.length];
                const edge = Vec.sub(p2, p1);
                const normal = Vec.normalize({ x: edge.y, y: -edge.x });
                this.worldNormals.push(normal);
            }
        }
        
        isPointInside(point) {
            // Ray casting algorithm
            let inside = false;
            for (let i = 0, j = this.worldVertices.length - 1; i < this.worldVertices.length; j = i++) {
                const xi = this.worldVertices[i].x, yi = this.worldVertices[i].y;
                const xj = this.worldVertices[j].x, yj = this.worldVertices[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        applyForce(force, contactPoint) {
            // Apply linear force
            this.vel = Vec.add(this.vel, Vec.scale(force, this.invMass));
            // Apply torque
            const r = Vec.sub(contactPoint, this.pos);
            const torque = Vec.cross(r, force);
            this.angularVel += torque * this.invInertia;
        }

        draw(ctx) {
            ctx.beginPath();
            ctx.moveTo(this.worldVertices[0].x, this.worldVertices[0].y);
            for (let i = 1; i < this.worldVertices.length; i++) {
                ctx.lineTo(this.worldVertices[i].x, this.worldVertices[i].y);
            }
            ctx.closePath();
            
            const speed = Vec.len(this.vel);
            const hue = (Date.now() / 50 + speed / 5) % 360;
            ctx.strokeStyle = `hsl(${hue}, 100%, 75%)`;
            ctx.lineWidth = 4;
            ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    }

    /**
     * Represents a single ball.
     */
    class Ball {
        constructor(pos, radius) {
            this.pos = pos;
            this.oldPos = {x: pos.x - (Math.random()-0.5), y: pos.y - (Math.random()-0.5)};
            this.accel = { x: 0, y: 0 };
            this.radius = radius;
            this.mass = config.ballMassFromRadius ? Math.PI * radius * radius : 10;
            this.invMass = 1 / this.mass;
            this.restitution = config.ballRestitution;
            this.color = `hsl(${Math.random() * 360}, 90%, 70%)`;
        }

        update(dt) {
            const vel = Vec.sub(this.pos, this.oldPos);

            // Verlet integration
            this.oldPos = this.pos;
            const newPos = Vec.add(this.pos, vel);
            const finalPos = Vec.add(newPos, Vec.scale(this.accel, dt * dt));
            this.pos = finalPos;

            this.accel = { x: 0, y: 0 };
        }

        applyForce(force) {
            this.accel = Vec.add(this.accel, Vec.scale(force, this.invMass));
        }

        draw(ctx) {
            ctx.beginPath();
            const gradient = ctx.createRadialGradient(
                this.pos.x - this.radius * 0.2, this.pos.y - this.radius * 0.2, this.radius * 0.1,
                this.pos.x, this.pos.y, this.radius
            );
            gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.7, this.color);
            gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
            
            ctx.fillStyle = gradient;
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // --- PHYSICS ENGINE ---

    function updatePhysics(dt) {
        // Apply global forces (gravity)
        balls.forEach(ball => ball.applyForce(gravity));

        // Using a simplified gravity force on the polygon's center of mass
        polygon.vel.x += gravity.x * dt;
        polygon.vel.y += gravity.y * dt;

        // Integrate polygon motion
        polygon.pos.x += polygon.vel.x * dt;
        polygon.pos.y += polygon.vel.y * dt;
        polygon.angle += polygon.angularVel * dt;
        
        // Apply damping
        polygon.vel.x *= (1 - polygon.linearDamping * dt);
        polygon.vel.y *= (1 - polygon.linearDamping * dt);
        polygon.angularVel *= (1 - polygon.angularDamping * dt);

        polygon.updateWorldVertices();

        // Integrate balls and solve constraints in substeps
        const sub_dt = dt / config.substeps;
        for (let i = 0; i < config.substeps; i++) {
            balls.forEach(ball => ball.update(sub_dt));
            solveCollisions();
        }
    }

    function solveCollisions() {
        // 1. Balls vs Polygon Edges
        balls.forEach(ball => {
            for (let i = 0; i < polygon.worldVertices.length; i++) {
                const p1 = polygon.worldVertices[i];
                const p2 = polygon.worldVertices[(i + 1) % polygon.worldVertices.length];
                const edge = Vec.sub(p2, p1);
                const normal = polygon.worldNormals[i];

                const ballToP1 = Vec.sub(ball.pos, p1);
                const distToEdgePlane = Vec.dot(ballToP1, normal);
                
                if (distToEdgePlane < ball.radius) {
                    // Check if closest point is on the segment
                    const dot1 = Vec.dot(ballToP1, edge);
                    const dot2 = Vec.dot(Vec.sub(ball.pos, p2), Vec.scale(edge, -1));

                    if (dot1 > 0 && dot2 > 0) { // Collision with the edge line
                        const penetration = ball.radius - distToEdgePlane;
                        // Positional correction
                        ball.pos = Vec.add(ball.pos, Vec.scale(normal, penetration));

                        // Impulse resolution
                        const vel = Vec.sub(ball.pos, ball.oldPos);
                        const normalVel = Vec.dot(vel, normal);
                        if (normalVel < 0) {
                            const tangent = {x: -normal.y, y: normal.x};
                            const tangentVel = Vec.dot(vel, tangent);
                            
                            const j = -(1 + config.ballRestitution) * normalVel;
                            const frictionImpulse = -tangentVel * config.friction;

                            const impulse = Vec.add(Vec.scale(normal, j), Vec.scale(tangent, frictionImpulse));
                            
                            const newVel = Vec.add(vel, impulse);
                            ball.oldPos = Vec.sub(ball.pos, newVel);
                        }
                    }
                }
            }
        });

        // 2. Ball vs Ball
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                const b1 = balls[i];
                const b2 = balls[j];
                const axis = Vec.sub(b1.pos, b2.pos);
                const distSq = Vec.lenSq(axis);
                const totalRadius = b1.radius + b2.radius;

                if (distSq < totalRadius * totalRadius) {
                    const dist = Math.sqrt(distSq);
                    const normal = dist > 0 ? Vec.scale(axis, 1 / dist) : {x:1, y:0};
                    const penetration = totalRadius - dist;
                    const totalInvMass = b1.invMass + b2.invMass;

                    // Positional correction
                    const correction = Vec.scale(normal, penetration / totalInvMass * config.baumgarte);
                    b1.pos = Vec.add(b1.pos, Vec.scale(correction, b1.invMass));
                    b2.pos = Vec.sub(b2.pos, Vec.scale(correction, b2.invMass));

                    // Impulse resolution
                    const v1 = Vec.sub(b1.pos, b1.oldPos);
                    const v2 = Vec.sub(b2.pos, b2.oldPos);
                    const relVel = Vec.sub(v1, v2);
                    const normalVel = Vec.dot(relVel, normal);

                    if (normalVel < 0) {
                        const restitution = Math.min(b1.restitution, b2.restitution);
                        const j = -(1 + restitution) * normalVel / totalInvMass;
                        const impulse = Vec.scale(normal, j);

                        const newV1 = Vec.add(v1, Vec.scale(impulse, b1.invMass));
                        const newV2 = Vec.sub(v2, Vec.scale(impulse, b2.invMass));
                        
                        b1.oldPos = Vec.sub(b1.pos, newV1);
                        b2.oldPos = Vec.sub(b2.pos, newV2);
                    }
                }
            }
        }
        
        // 3. Polygon vs Canvas Walls
        polygon.worldVertices.forEach(v => {
            let penetration = 0;
            let normal = { x: 0, y: 0 };
            
            if (v.x < 0) { penetration = -v.x; normal = {x: 1, y: 0}; }
            else if (v.x > width) { penetration = width - v.x; normal = {x: -1, y: 0}; }
            if (v.y < 0) { penetration = -v.y; normal = {x: 0, y: 1}; }
            else if (v.y > height) { penetration = height - v.y; normal = {x: 0, y: -1}; }

            if (penetration !== 0) {
                // Positional correction (robustly move the polygon out of the wall)
                polygon.pos.x += normal.x * Math.abs(penetration);
                polygon.pos.y += normal.y * Math.abs(penetration);
                polygon.updateWorldVertices();

                // Impulse-based response
                const r = Vec.sub(v, polygon.pos);
                const r_perp = { x: -r.y, y: r.x };
                const v_point = Vec.add(polygon.vel, Vec.scale(r_perp, polygon.angularVel));

                const normalVel = Vec.dot(v_point, normal);
                if (normalVel < 0) { // Moving towards the wall
                     const numerator = -(1 + polygon.restitution) * normalVel;
                     const term1 = polygon.invMass;
                     const term2 = Math.pow(Vec.cross(r, normal), 2) * polygon.invInertia;
                     const j = numerator / (term1 + term2);
                     const impulse = Vec.scale(normal, j);
                     
                     polygon.vel = Vec.add(polygon.vel, Vec.scale(impulse, polygon.invMass));
                     polygon.angularVel += Vec.cross(r, impulse) * polygon.invInertia;
                }
            }
        });
    }

    // --- RENDERING ---

    function draw(time) {
        if (config.paused) return;

        const dt = Math.min(0.05, (time - lastTime) / 1000); // Clamp delta time
        lastTime = time;
        const scaledDt = dt * config.timeScale;

        // Update gravity
        if (config.gravityMode === 'varying') {
            gravityAngle += config.gravityDirectionChangeSpeed * scaledDt;
            const mag = config.gravityMagnitudeRange[0] + 
                (Math.sin(gravityAngle * 0.7) + 1) / 2 * (config.gravityMagnitudeRange[1] - config.gravityMagnitudeRange[0]);
            gravity.x = mag * Math.cos(gravityAngle);
            gravity.y = mag * Math.sin(gravityAngle);
        }

        // Physics step
        updatePhysics(scaledDt);
        
        // Drawing step
        if (config.trail) {
            ctx.fillStyle = `rgba(26, 26, 46, ${config.trailFadeAmount})`;
            ctx.fillRect(0, 0, width, height);
        } else {
            ctx.clearRect(0, 0, width, height);
        }

        drawGravityIndicator();
        polygon.draw(ctx);
        balls.forEach(ball => ball.draw(ctx));

        animationFrameId = requestAnimationFrame(draw);
    }
    
    function drawGravityIndicator() {
        const center = {x: 50, y: 50};
        const gNorm = Vec.normalize(gravity);
        const gMag = Vec.len(gravity);
        const arrowLength = 20 + 20 * (gMag - config.gravityMagnitudeRange[0]) / (config.gravityMagnitudeRange[1] - config.gravityMagnitudeRange[0]);
        const end = Vec.add(center, Vec.scale(gNorm, arrowLength));
        
        ctx.save();
        ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        
        ctx.translate(end.x, end.y);
        ctx.rotate(Math.atan2(gNorm.y, gNorm.x));
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(-8, -4);
        ctx.lineTo(-8, 4);
        ctx.closePath();
        ctx.fillStyle = 'rgba(200, 200, 255, 0.5)';
        ctx.fill();
        ctx.restore();
    }


    // --- INITIALIZATION AND UI ---

    function setupCanvas() {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.scale(dpr, dpr);
    }
    
    function init() {
        polygon = new Polygon();
        balls = [];
        let attempts = 0;
        
        while (balls.length < config.ballsCount && attempts < 5000) {
            const radius = config.ballRadiusRange[0] + Math.random() * (config.ballRadiusRange[1] - config.ballRadiusRange[0]);
            
            // Attempt to place a ball inside the polygon
            const pos = {
                x: polygon.pos.x + (Math.random() - 0.5) * (config.polygonSize - radius) * 1.5,
                y: polygon.pos.y + (Math.random() - 0.5) * (config.polygonSize - radius) * 1.5
            };

            if (polygon.isPointInside(pos)) {
                // Check for overlap with existing balls
                let overlap = false;
                for(const other of balls) {
                    const distSq = Vec.lenSq(Vec.sub(pos, other.pos));
                    if (distSq < Math.pow(radius + other.radius + 5, 2)) { // add a small buffer
                        overlap = true;
                        break;
                    }
                }
                if (!overlap) {
                    balls.push(new Ball(pos, radius));
                }
            }
            attempts++;
        }
        
        if (attempts >= 5000) {
            console.warn(`Could not place all ${config.ballsCount} balls. Placed ${balls.length}. Try a larger polygon or fewer balls.`);
            config.ballsCount = balls.length;
            document.getElementById('ballsCount').value = balls.length;
            document.getElementById('ballsCountValue').textContent = balls.length;
        }
    }

    function setupUI() {
        const controls = {
            polygonSides: 'polygonSidesValue',
            ballsCount: 'ballsCountValue',
            spinSpeed: 'spinSpeedValue',
            timeScale: 'timeScaleValue'
        };

        for (const [id, valueId] of Object.entries(controls)) {
            const el = document.getElementById(id);
            const valueEl = document.getElementById(valueId);
            el.addEventListener('input', () => {
                const value = id === 'spinSpeed' || id === 'timeScale' ? parseFloat(el.value) : parseInt(el.value, 10);
                config[id] = value;
                valueEl.textContent = el.value;
                if(id === 'polygonSides') polygon.generateVertices();
                if(id === 'spinSpeed') polygon.angularVel = value;
            });
        }
        
        document.getElementById('trail').addEventListener('change', (e) => config.trail = e.target.checked);
        document.getElementById('randomizeBtn').addEventListener('click', () => {
            setupCanvas();
            init();
        });
        document.getElementById('pauseBtn').addEventListener('click', () => {
            config.paused = !config.paused;
            document.getElementById('pauseBtn').textContent = config.paused ? 'Resume' : 'Pause';
            if (!config.paused) {
                lastTime = performance.now();
                requestAnimationFrame(draw);
            }
        });
    }

    // --- START ---

    window.addEventListener('resize', () => {
        // Debounce resize
        cancelAnimationFrame(animationFrameId);
        setupCanvas();
        init();
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(draw);
    });
    
    setupUI();
    setupCanvas();
    init();
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(draw);

    </script>
</body>
</html>